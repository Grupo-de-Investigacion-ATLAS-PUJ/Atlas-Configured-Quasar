
{# <!-- Â© Copyright CERN, 2015.                                                       -->
<!-- All rights not expressly granted are reserved.                                -->
<!-- This file is part of Quasar.                                                  -->
<!--                                                                               -->
<!-- Quasar is free software: you can redistribute it and/or modify                -->     
<!-- it under the terms of the GNU Lesser General Public Licence as published by   -->     
<!-- the Free Software Foundation, either version 3 of the Licence.                -->     
<!-- Quasar is distributed in the hope that it will be useful,                     -->     
<!-- but WITHOUT ANY WARRANTY; without even the implied warranty of                -->     
<!--                                                                               -->
<!-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                 -->
<!-- GNU Lesser General Public Licence for more details.                           -->
<!--                                                                               -->
<!-- You should have received a copy of the GNU Lesser General Public License      -->
<!-- along with Quasar.  If not, see <http://www.gnu.org/licenses/>                -->
<!--                                                                               -->
<!-- Created:   Sep 2014                                                           -->
<!-- Authors:                                                                      -->
<!--   Piotr Nikiel <piotr@nikiel.info>                                            --> #}

#include <SourceVariables.h>
#include <LogIt.h>
using namespace std;

{% for className in designInspector.get_names_of_all_classes(only_with_device_logic=True) %}
  #include <Base_D{{className}}.h>
{% endfor %}

namespace AddressSpace
{

/* The thread pool should be initialized by Meta while reading the config file, using function: 
    SourceVariables_initSourceVariablesThreadPool */
static Quasar::ThreadPool *sourceVariableThreads = nullptr;
void SourceVariables_initSourceVariablesThreadPool (unsigned int minThreads, unsigned int maxThreads, unsigned int maxJobs)
{
  LOG(Log::DBG) << "Initializing source variables thread pool to min=" << minThreads  << " max=" << maxThreads << " threads maxJobs=" << " jobs";
  sourceVariableThreads = new Quasar::ThreadPool (maxThreads, maxJobs);
}

void SourceVariables_destroySourceVariablesThreadPool ()
{
  if (sourceVariableThreads)
  {
    delete sourceVariableThreads;
    sourceVariableThreads = nullptr;
  }
}

Quasar::ThreadPool* SourceVariables_getThreadPool () { return sourceVariableThreads; }
}

#ifndef BACKEND_OPEN62541


#include <iomanager.h>

#include <iostream>
#include <stdexcept>

#include <QuasarThreadPool.h>
  
{% for className in designInspector.get_names_of_all_classes() %}
  {% if designInspector.objectify_source_variables(className)|length > 0 %}
    #include <AS{{className}}.h>
    {% if designInspector.class_has_device_logic(className) %}
      #include <D{{className}}.h>
    {% endif %}
  {% endif %}
{% endfor %}

namespace AddressSpace
{

{% for className in designInspector.get_names_of_all_classes(only_with_device_logic=True) %}
  {% for sv in designInspector.objectify_source_variables(className, restrict_by="[@addressSpaceRead='asynchronous' or @addressSpaceRead='synchronous']") %}
    class IoJob_{{className}}_READ_{{sv.get('name')}} : public Quasar::ThreadPoolJob
    {
      public:
        IoJob_{{className}}_READ_{{sv.get('name')}} (
          IOManagerCallback *callback,
          OpcUa_UInt32 hTransaction,
          OpcUa_UInt32 callbackHandle,
          const UaNode* parentObjectNode
        ):
          m_callback(callback),
          m_hTransaction(hTransaction),
          m_callbackHandle (callbackHandle),
          m_parentObjectNode (parentObjectNode)
        {}
        
      virtual void execute ()
      {
        LOG(Log::DBG) << 
          "Executing IoJob read: className={{className}} varName={{sv.get('name')}}" <<
          " hTransaction:" << m_hTransaction << 
          " cbkhandle " << m_callbackHandle;
        UaStatus s;
        {{sv.get('dataType')}} value;
        UaDateTime sourceTime;
        // Obtain Device Logic object
        const AS{{className}}* addressSpaceObject (nullptr);
        addressSpaceObject = dynamic_cast<const AS{{className}}*> ( m_parentObjectNode );
        if (addressSpaceObject == m_parentObjectNode)
        { /* OK. Proper cast. */
          Device::D{{className}}* device = addressSpaceObject->getDeviceLink();
          if (device != 0)
          {
            /* OK - Device Logic linked. */
            {% if sv.get('addressSpaceReadUseMutex') == 'of_this_operation' %}
              device->lockVariableRead_{{sv.get('name')}} ();
            {% elif sv.get('addressSpaceReadUseMutex') == 'of_this_variable' %}
              device->lockVariable_{{sv.get('name')}} ();
            {% elif sv.get('addressSpaceReadUseMutex') == 'of_containing_object' %}
              device->lock();
            {% elif sv.get('addressSpaceReadUseMutex') == 'of_parent_of_containing_object' %}  
              device->getParent()->lock();
            {% endif %}
            try
            {
              s = device->read{{sv.get('name')|capFirst}} (value, sourceTime );
            }
            catch (...)
            {
              /* TODO -- how to signalize error from here */
              LOG(Log::ERR) << "An exception was thrown from read{{sv.get('name')|capFirst}}";
              s = OpcUa_BadInternalError;
            }
            {% if sv.get('addressSpaceReadUseMutex') == 'of_this_operation' %}
              device->unlockVariableRead_{{sv.get('name')}} ();
            {% elif sv.get('addressSpaceReadUseMutex') == 'of_this_variable' %}
              device->unlockVariable_{{sv.get('name')}} ();
            {% elif sv.get('addressSpaceReadUseMutex') == 'of_containing_object' %}
              device->unlock();
            {% elif sv.get('addressSpaceReadUseMutex') == 'of_parent_of_containing_object' %}  
              device->getParent()->unlock();
            {% endif %}
          }
          else
            s = OpcUa_BadInternalError;
        }
        else
          s = OpcUa_BadInternalError; // dynamic_cast failure, TODO move away from execute()
        UaDataValue result (UaVariant(value), s.statusCode(), sourceTime, UaDateTime::now());
        // get appropriate object
        s = m_callback->finishRead (
          m_hTransaction,
          m_callbackHandle,
          result
        );
        LOG(Log::DBG) << "After finishRead status:" << s.toString().toUtf8();
      }

      virtual std::string describe() const
      {
        return std::string("read sourcevariable {{sv.get('name')}} of object ") + m_parentObjectNode->nodeId().toString().toUtf8();
      }

      private:
        IOManagerCallback* m_callback;
        OpcUa_UInt32       m_hTransaction;
        OpcUa_UInt32       m_callbackHandle;
        const UaNode*      m_parentObjectNode;

    };
  {% endfor %}
  
  {% for sv in designInspector.objectify_source_variables(className, restrict_by="[@addressSpaceWrite='asynchronous' or @addressSpaceWrite='synchronous']") %}
    class IoJob_{{className}}_WRITE_{{sv.get('name')}} : public Quasar::ThreadPoolJob
    {
      public:
        IoJob_{{className}}_WRITE_{{sv.get('name')}} (
          IOManagerCallback* callback,
          OpcUa_UInt32       hTransaction,
          OpcUa_UInt32       callbackHandle,
          const UaNode*      parentObjectNode,
          OpcUa_WriteValue*  writeValue
        ):
          m_callback(callback),
          m_hTransaction(hTransaction),
          m_callbackHandle (callbackHandle),
          m_parentObjectNode (parentObjectNode),
          m_variant (writeValue->Value.Value)    
        {
        }
        
        virtual std::string describe() const
        {
            return std::string("write sourcevariable <xsl:value-of select="$variableName"/> of object ") + m_parentObjectNode->nodeId().toString().toUtf8();
        }
        
        
      private:
        IOManagerCallback* m_callback;
        OpcUa_UInt32       m_hTransaction;
        OpcUa_UInt32       m_callbackHandle;
        const UaNode*      m_parentObjectNode;
        UaVariant          m_variant;
    };
  {% endfor %}
  
{% endfor %}
{#
<xsl:if test="@addressSpaceWrite='asynchronous' or @addressSpaceWrite='synchronous'">
<xsl:call-template name="WriteJob">
<xsl:with-param name="className"><xsl:value-of select="$className"/></xsl:with-param>
          <xsl:with-param name="variableName"><xsl:value-of select="@name"/></xsl:with-param>
          
          <xsl:template  name="WriteJob">
          <xsl:param name="className"/>
            <xsl:param name="variableName"/>

          virtual void execute ()
          {
              LOG(Log::DBG) << "Executing IoJob write: className=<xsl:value-of select="$className"/> varName=<xsl:value-of select="@name"/>" << "hTransaction:"<<m_hTransaction<<" cbkhandle "<< m_callbackHandle<<endl;
          UaStatus s;
          
          <xsl:value-of select="@dataType"/> value;
          <xsl:choose>
          <xsl:when test="@dataType='UaVariant'">
          value = m_variant;
          if (true)
          {
          </xsl:when>
          <xsl:otherwise>
          if (m_variant.type() == <xsl:value-of select="fnc:dataTypeToBuiltinType(@dataType)"/>)
          {
          <xsl:choose>
          <xsl:when test="@dataType='UaString'">
          value = m_variant.toString();
          </xsl:when>
          <xsl:otherwise>
          m_variant.<xsl:value-of select="fnc:dataTypeToVariantConverter(@dataType)"/> ( value );
          </xsl:otherwise>
          </xsl:choose>
          
          </xsl:otherwise>
          </xsl:choose>

          // Obtain Device Logic object
          const <xsl:value-of select="fnc:ASClassName($className)"/> *addressSpaceObject;
          addressSpaceObject = dynamic_cast<const <xsl:value-of select="fnc:ASClassName($className)"/>* > ( m_parentObjectNode );
          if (addressSpaceObject == m_parentObjectNode)
          { /* OK. Proper cast. */
          Device::<xsl:value-of select="fnc:DClassName($className)"/> *device = addressSpaceObject->getDeviceLink();
          if (device != 0)
          {
          <xsl:choose >
          <xsl:when test="@addressSpaceWriteUseMutex='of_this_operation'">
          device->lockVariableWrite_<xsl:value-of select="@name"/> ();
          </xsl:when>
          <xsl:when test="@addressSpaceWriteUseMutex='of_this_variable'">
          device->lockVariable_<xsl:value-of select="@name"/> ();
          </xsl:when>
          <xsl:when test="@addressSpaceWriteUseMutex='of_containing_object'">
          device->lock();
          </xsl:when>
          <xsl:when test="@addressSpaceWriteUseMutex='of_parent_of_containing_object'">
          device->getParent()->lock();
          </xsl:when>
          </xsl:choose>
          /* OK - Device Logic linked. */
          try
          {
          s = device->write<xsl:value-of select="fnc:capFirst(@name)"/> (value );
          }
          catch (...)
          {
          /* TODO -- how to signalize error from here */
          LOG(Log::ERR) << "An exception was thrown from write<xsl:value-of select="fnc:capFirst(@name)"/>" << std::endl;
          s = OpcUa_BadInternalError;
          }
          <xsl:choose >
          <xsl:when test="@addressSpaceWriteUseMutex='of_this_operation'">
          device->unlockVariableWrite_<xsl:value-of select="@name"/> ();
          </xsl:when>
          <xsl:when test="@addressSpaceWriteUseMutex='of_this_variable'">
          device->unlockVariable_<xsl:value-of select="@name"/> ();
          </xsl:when>
          <xsl:when test="@addressSpaceWriteUseMutex='of_containing_object'">
          device->unlock();
          </xsl:when>
          <xsl:when test="@addressSpaceWriteUseMutex='of_parent_of_containing_object'">
          device->getParent()->unlock();
          </xsl:when>
          </xsl:choose>
          
          }
          else
          s = OpcUa_BadInternalError;
          }
          else
          s = OpcUa_BadInternalError;
          }
          else
              s = OpcUa_BadDataEncodingInvalid;
          UaDataValue result (UaVariant(value), s.statusCode(), UaDateTime::now(), UaDateTime::now());
          // get appropriate object
          s = m_callback->finishWrite (
          m_hTransaction,
          m_callbackHandle,
          s
          );
          LOG(Log::TRC) << "After finishWrite status:" << s.toString().toUtf8() << endl;
          
          }

          };
          
          </xsl:template>
          
</xsl:call-template>

</xsl:if>
</xsl:for-each>
</xsl:for-each> #}

UaStatus SourceVariables_spawnIoJobRead (		
  ASSourceVariableJobId jobId,
  IOManagerCallback *callback,
  OpcUa_UInt32 hTransaction,
  OpcUa_UInt32        callbackHandle,
  const UaNode *parentNode
)
{
  if (! sourceVariableThreads)
    throw std::runtime_error("Attempted Source Variable operation, but Source Variable threads are not up.");
  switch (jobId)
  {
    {% for className in designInspector.get_names_of_all_classes() %}
      {% set class = designInspector.objectify_class(className) %}
      {% for sv in class.sourcevariable %}
        {% if sv.get('addressSpaceRead') != 'forbidden' %}
        case ASSOURCEVARIABLE_{{className}}_READ_{{sv.get('name')}}:
          {% if not designInspector.class_has_device_logic(className) %}
            return OpcUa_BadNotImplemented; // because this class has no device logic
          {% else %}
            {% if sv.get('addressSpaceRead') == 'asynchronous' or sv.get('addressSpaceRead') == 'synchronous' %}
              {
                {% if sv.get('addressSpaceRead') == 'asynchronous' %}
                  IoJob_{{className}}_READ_{{sv.get('name')}}* job =
                    new IoJob_{{className}}_READ_{{sv.get('name')}} (
                      callback,
                      hTransaction,
                      callbackHandle,
                      parentNode
                      ); 
                  UaStatus s = sourceVariableThreads->addJob (job);
                  if (!s.isGood())
                  {
                    LOG(Log::ERR) << "While addJob(): " << s.toString().toUtf8();
                  }
                  return s;
                {% elif sv.get('addressSpaceRead') == 'synchronous' %}
                  IoJob_{{className}}_READ_<xsl:value-of select="@name"/> job (
                    callback,
                    hTransaction,
                    callbackHandle,
                    parentNode
                    ); 
                  job.execute();
                {% else %}
                  {{debug("Source-variable mode is unsupported and the generated code will probably be faulty. Mode was: ", sv.get('addressSpaceRead'))}}
                {% endif %}
              }
              return OpcUa_Good;
            {% endif %}
          {% endif %}
        {% endif %}
      {% endfor %}
    {% endfor %}
    default:
      return OpcUa_Bad;
  }
}

UaStatus SourceVariables_spawnIoJobWrite (		
  ASSourceVariableJobId jobId,
  IOManagerCallback *callback,
  OpcUa_UInt32 hTransaction,
  OpcUa_UInt32        callbackHandle,
  const UaNode *parentNode,
  OpcUa_WriteValue*   pWriteValue
)
{
  if (! sourceVariableThreads)
  throw std::runtime_error("Attempted Source Variable operation, but Source Variable threads are not up.");
  switch (jobId)
  {
    {% for className in designInspector.get_names_of_all_classes() %}
      {% set class = designInspector.objectify_class(className) %}
      {% for sv in class.sourcevariable %}
        {% if sv.get('addressSpaceWrite') != 'forbidden' %}
          case ASSOURCEVARIABLE_{{className}}_READ_{{sv.get('name')}}:
            {% if not designInspector.class_has_device_logic(className) %}
              return OpcUa_BadNotImplemented; // because this class has no device logic
            {% else %}
              {% if sv.get('addressSpaceWrite') == 'asynchronous' or sv.get('addressSpaceWrite') == 'synchronous' %}
                {
                  {% if sv.get('addressSpaceWrite') == 'asynchronous' %}
                    IoJob_{{className}}_WRITE_{{sv.get('name')}} *job =
                      new IoJob_{{className}}_WRITE_{{sv.get('name')}} (
                        callback,
                        hTransaction,
                        callbackHandle,
                        parentNode,
                        pWriteValue
                      ); 
                    UaStatus s = sourceVariableThreads->addJob (job);
                    if (!s.isGood())
                        LOG(Log::ERR) << "While addJob(): " << s.toString().toUtf8();
                    return s;
                  {% elif sv.get('addressSpaceWrite') == 'synchronous' %}
                    IoJob_{{className}}_WRITE_{{sv.get('name')}} job (
                      callback,
                      hTransaction,
                      callbackHandle,
                      parentNode,
                      pWriteValue
                    ); 
                    job.execute();
                  {% else %}
                    {{debug("Source-variable mode is unsupported and the generated code will probably be faulty. Mode was: ", sv.get('addressSpaceWrite'))}}
                  {% endif %}
                }  
              {% endif %}
            {% endif %}
        {% endif %}
      {% endfor %}
    {% endfor %}
    default:
      return OpcUa_Bad;
  }
}

}

#endif // BACKEND_OPEN62541
