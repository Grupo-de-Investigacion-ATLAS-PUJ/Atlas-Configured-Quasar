<?xml version="1.0" encoding="UTF-8"?>
{# <!-- Â© Copyright CERN, 2015.                                                       -->
<!-- All rights not expressly granted are reserved.                                -->
<!-- This file is part of Quasar.                                                  -->
<!--                                                                               -->
<!-- Quasar is free software: you can redistribute it and/or modify                -->     
<!-- it under the terms of the GNU Lesser General Public Licence as published by   -->     
<!-- the Free Software Foundation, either version 3 of the Licence.                -->     
<!-- Quasar is distributed in the hope that it will be useful,                     -->     
<!-- but WITHOUT ANY WARRANTY; without even the implied warranty of                -->     
<!--                                                                               -->
<!-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the                 -->
<!-- GNU Lesser General Public Licence for more details.                           -->
<!--                                                                               -->
<!-- You should have received a copy of the GNU Lesser General Public License      -->
<!-- along with Quasar.  If not, see <http://www.gnu.org/licenses/>                -->
<!--                                                                               -->
<!-- Created:   Sep 2014                                                           -->
<!-- Authors:                                                                      -->
<!--   Piotr Nikiel <piotr@nikiel.info>                                            --> #}

#include <SourceVariables.h>
#include <LogIt.h>
using namespace std;

{% for className in designInspector.get_names_of_all_classes(only_with_device_logic=True) %}
  #include <Base_D{{className}}.h>
{% endfor %}

namespace AddressSpace
{

/* The thread pool should be initialized by Meta while reading the config file, using function: 
    SourceVariables_initSourceVariablesThreadPool */
static Quasar::ThreadPool *sourceVariableThreads = nullptr;
void SourceVariables_initSourceVariablesThreadPool (unsigned int minThreads, unsigned int maxThreads, unsigned int maxJobs)
{
  LOG(Log::DBG) << "Initializing source variables thread pool to min=" << minThreads  << " max=" << maxThreads << " threads maxJobs=" << " jobs";
  sourceVariableThreads = new Quasar::ThreadPool (maxThreads, maxJobs);
}

void SourceVariables_destroySourceVariablesThreadPool ()
{
  if (sourceVariableThreads)
  {
    delete sourceVariableThreads;
    sourceVariableThreads = nullptr;
  }
}

Quasar::ThreadPool* SourceVariables_getThreadPool () { return sourceVariableThreads; }
}

#ifndef BACKEND_OPEN62541


#include <iomanager.h>

#include <iostream>
#include <stdexcept>

#include <QuasarThreadPool.h>

{# <xsl:for-each select="/d:design/d:class">
<xsl:if test="count(d:sourcevariable)>0">
#include <<xsl:value-of select="fnc:ASClassName(@name)"/>.h>
<xsl:if test="fnc:classHasDeviceLogic(/,@name)='true'">
#include <<xsl:value-of select="fnc:DClassName(@name)"/>.h>
</xsl:if>
</xsl:if>
</xsl:for-each> #}

namespace AddressSpace
{

{# <xsl:for-each select="/d:design/d:class[d:devicelogic]">
<xsl:variable name="className"><xsl:value-of select="@name"/></xsl:variable>
<xsl:for-each select="d:sourcevariable">
<xsl:if test="@addressSpaceRead='asynchronous' or @addressSpaceRead='synchronous' ">
<xsl:call-template name="ReadJob">
<xsl:with-param name="className"><xsl:value-of select="$className"/></xsl:with-param>
<xsl:with-param name="variableName"><xsl:value-of select="@name"/></xsl:with-param>

<xsl:template  name="ReadJob">
<xsl:param name="className"/>
<xsl:param name="variableName"/>

class IoJob_<xsl:value-of select="$className"/>_READ_<xsl:value-of select="$variableName"/> : public Quasar::ThreadPoolJob
{
public:
IoJob_<xsl:value-of select="$className"/>_READ_<xsl:value-of select="$variableName"/> (
IOManagerCallback *callback,
OpcUa_UInt32 hTransaction,
OpcUa_UInt32 callbackHandle,
const UaNode* parentObjectNode
):
m_callback(callback),
m_hTransaction(hTransaction),
m_callbackHandle (callbackHandle),
m_parentObjectNode (parentObjectNode)
{}
virtual void execute ()
{
LOG(Log::DBG) << "Executing IoJob read: className=<xsl:value-of select="$className"/> varName=<xsl:value-of select="$variableName"/>" << "hTransaction:"<<m_hTransaction<<" cbkhandle "<< m_callbackHandle<<endl;
UaStatus s;
<xsl:value-of select="@dataType"/> value;
UaDateTime sourceTime;
// Obtain Device Logic object
const <xsl:value-of select="fnc:ASClassName($className)"/> *addressSpaceObject;
addressSpaceObject = dynamic_cast<const <xsl:value-of select="fnc:ASClassName($className)"/>* > ( m_parentObjectNode );
if (addressSpaceObject == m_parentObjectNode)
{ /* OK. Proper cast. */
Device::<xsl:value-of select="fnc:DClassName($className)"/> *device = addressSpaceObject->getDeviceLink();
if (device != 0)
{
/* OK - Device Logic linked. */
<xsl:choose >
<xsl:when test="@addressSpaceReadUseMutex='of_this_operation'">
device->lockVariableRead_<xsl:value-of select="@name"/> ();
</xsl:when>
<xsl:when test="@addressSpaceReadUseMutex='of_this_variable'">
device->lockVariable_<xsl:value-of select="@name"/> ();
</xsl:when>
<xsl:when test="@addressSpaceReadUseMutex='of_containing_object'">
device->lock();
</xsl:when>
<xsl:when test="@addressSpaceReadUseMutex='of_parent_of_containing_object'">
device->getParent()->lock();
</xsl:when>
</xsl:choose>
try
{
s = device->read<xsl:value-of select="fnc:capFirst($variableName)"/> (value, sourceTime );
}
catch (...)
{
/* TODO -- how to signalize error from here */
LOG(Log::ERR) << "An exception was thrown from read<xsl:value-of select="fnc:capFirst($variableName)"/>" << std::endl;
s = OpcUa_BadInternalError;
}
<xsl:choose >
<xsl:when test="@addressSpaceReadUseMutex='of_this_operation'">
device->unlockVariableRead_<xsl:value-of select="@name"/> ();
</xsl:when>
<xsl:when test="@addressSpaceReadUseMutex='of_this_variable'">
device->unlockVariable_<xsl:value-of select="@name"/> ();
</xsl:when>
<xsl:when test="@addressSpaceReadUseMutex='of_containing_object'">
device->unlock();
</xsl:when>
<xsl:when test="@addressSpaceReadUseMutex='of_parent_of_containing_object'">
device->getParent()->unlock();
</xsl:when>
</xsl:choose>
}
else
s = OpcUa_BadInternalError;
}
else
s = OpcUa_BadInternalError;
UaDataValue result (UaVariant(value), s.statusCode(), sourceTime, UaDateTime::now());
// get appropriate object
s = m_callback->finishRead (
m_hTransaction,
m_callbackHandle,
result
);
LOG(Log::DBG) << "After finishRead status:" << s.toString().toUtf8() << endl;

}
      virtual std::string describe() const
      {
          return std::string("read sourcevariable <xsl:value-of select="$variableName"/> of object ") + m_parentObjectNode->nodeId().toString().toUtf8();
      }
private:
IOManagerCallback *m_callback;
OpcUa_UInt32 m_hTransaction;
OpcUa_UInt32 m_callbackHandle;
const UaNode* m_parentObjectNode;
};

</xsl:template>


</xsl:call-template>
</xsl:if>

<xsl:if test="@addressSpaceWrite='asynchronous' or @addressSpaceWrite='synchronous'">
<xsl:call-template name="WriteJob">
<xsl:with-param name="className"><xsl:value-of select="$className"/></xsl:with-param>
          <xsl:with-param name="variableName"><xsl:value-of select="@name"/></xsl:with-param>
          
          <xsl:template  name="WriteJob">
          <xsl:param name="className"/>
            <xsl:param name="variableName"/>
          
          class IoJob_<xsl:value-of select="$className"/>_WRITE_<xsl:value-of select="$variableName"/> : public Quasar::ThreadPoolJob
          {
          public:
          IoJob_<xsl:value-of select="$className"/>_WRITE_<xsl:value-of select="$variableName"/> (
          IOManagerCallback *callback,
          OpcUa_UInt32 hTransaction,
          OpcUa_UInt32 callbackHandle,
          const UaNode* parentObjectNode,
          OpcUa_WriteValue* writeValue
          ):
          m_callback(callback),
          m_hTransaction(hTransaction),
          m_callbackHandle (callbackHandle),
          m_parentObjectNode (parentObjectNode),
          m_variant (writeValue->Value.Value)
          
          {

          }
          virtual void execute ()
          {
              LOG(Log::DBG) << "Executing IoJob write: className=<xsl:value-of select="$className"/> varName=<xsl:value-of select="@name"/>" << "hTransaction:"<<m_hTransaction<<" cbkhandle "<< m_callbackHandle<<endl;
          UaStatus s;
          
          <xsl:value-of select="@dataType"/> value;
          <xsl:choose>
          <xsl:when test="@dataType='UaVariant'">
          value = m_variant;
          if (true)
          {
          </xsl:when>
          <xsl:otherwise>
          if (m_variant.type() == <xsl:value-of select="fnc:dataTypeToBuiltinType(@dataType)"/>)
          {
          <xsl:choose>
          <xsl:when test="@dataType='UaString'">
          value = m_variant.toString();
          </xsl:when>
          <xsl:otherwise>
          m_variant.<xsl:value-of select="fnc:dataTypeToVariantConverter(@dataType)"/> ( value );
          </xsl:otherwise>
          </xsl:choose>
          
          </xsl:otherwise>
          </xsl:choose>

          // Obtain Device Logic object
          const <xsl:value-of select="fnc:ASClassName($className)"/> *addressSpaceObject;
          addressSpaceObject = dynamic_cast<const <xsl:value-of select="fnc:ASClassName($className)"/>* > ( m_parentObjectNode );
          if (addressSpaceObject == m_parentObjectNode)
          { /* OK. Proper cast. */
          Device::<xsl:value-of select="fnc:DClassName($className)"/> *device = addressSpaceObject->getDeviceLink();
          if (device != 0)
          {
          <xsl:choose >
          <xsl:when test="@addressSpaceWriteUseMutex='of_this_operation'">
          device->lockVariableWrite_<xsl:value-of select="@name"/> ();
          </xsl:when>
          <xsl:when test="@addressSpaceWriteUseMutex='of_this_variable'">
          device->lockVariable_<xsl:value-of select="@name"/> ();
          </xsl:when>
          <xsl:when test="@addressSpaceWriteUseMutex='of_containing_object'">
          device->lock();
          </xsl:when>
          <xsl:when test="@addressSpaceWriteUseMutex='of_parent_of_containing_object'">
          device->getParent()->lock();
          </xsl:when>
          </xsl:choose>
          /* OK - Device Logic linked. */
          try
          {
          s = device->write<xsl:value-of select="fnc:capFirst(@name)"/> (value );
          }
          catch (...)
          {
          /* TODO -- how to signalize error from here */
          LOG(Log::ERR) << "An exception was thrown from write<xsl:value-of select="fnc:capFirst(@name)"/>" << std::endl;
          s = OpcUa_BadInternalError;
          }
          <xsl:choose >
          <xsl:when test="@addressSpaceWriteUseMutex='of_this_operation'">
          device->unlockVariableWrite_<xsl:value-of select="@name"/> ();
          </xsl:when>
          <xsl:when test="@addressSpaceWriteUseMutex='of_this_variable'">
          device->unlockVariable_<xsl:value-of select="@name"/> ();
          </xsl:when>
          <xsl:when test="@addressSpaceWriteUseMutex='of_containing_object'">
          device->unlock();
          </xsl:when>
          <xsl:when test="@addressSpaceWriteUseMutex='of_parent_of_containing_object'">
          device->getParent()->unlock();
          </xsl:when>
          </xsl:choose>
          
          }
          else
          s = OpcUa_BadInternalError;
          }
          else
          s = OpcUa_BadInternalError;
          }
          else
              s = OpcUa_BadDataEncodingInvalid;
          UaDataValue result (UaVariant(value), s.statusCode(), UaDateTime::now(), UaDateTime::now());
          // get appropriate object
          s = m_callback->finishWrite (
          m_hTransaction,
          m_callbackHandle,
          s
          );
          LOG(Log::TRC) << "After finishWrite status:" << s.toString().toUtf8() << endl;
          
          }
                virtual std::string describe() const
                {
                    return std::string("write sourcevariable <xsl:value-of select="$variableName"/> of object ") + m_parentObjectNode->nodeId().toString().toUtf8();
                }
          private:
          IOManagerCallback *m_callback;
          OpcUa_UInt32 m_hTransaction;
          OpcUa_UInt32 m_callbackHandle;
          const UaNode* m_parentObjectNode;
          UaVariant m_variant;
          };
          
          </xsl:template>
          
</xsl:call-template>

</xsl:if>
</xsl:for-each>
</xsl:for-each> #}

UaStatus SourceVariables_spawnIoJobRead (		
ASSourceVariableJobId jobId,
IOManagerCallback *callback,
OpcUa_UInt32 hTransaction,
OpcUa_UInt32        callbackHandle,
const UaNode *parentNode
)
{
if (! sourceVariableThreads)
throw std::runtime_error("Attempted Source Variable operation, but Source Variable threads are not up.");
switch (jobId)
{
<xsl:for-each select="/d:design/d:class">
<xsl:variable name="className"><xsl:value-of select="@name"/></xsl:variable>
<xsl:for-each select="d:sourcevariable[@addressSpaceRead!='forbidden']">
      case ASSOURCEVARIABLE_<xsl:value-of select="$className"/>_READ_<xsl:value-of select="@name"/>:
          <xsl:choose>
              <xsl:when test="fnc:classHasDeviceLogic(/,$className)!='true'">
                  return OpcUa_BadNotImplemented; // because this class has no device logic
              </xsl:when>
              <xsl:otherwise>
                  <xsl:if test="@addressSpaceRead='asynchronous' or @addressSpaceRead='synchronous'">      
                      
                      {
                          <xsl:choose>
                              <xsl:when test="@addressSpaceRead='asynchronous'">
                              IoJob_<xsl:value-of select="$className"/>_READ_<xsl:value-of select="@name"/> *job =
                              new IoJob_<xsl:value-of select="$className"/>_READ_<xsl:value-of select="@name"/> (
                              callback,
                              hTransaction,
                              callbackHandle,
                              parentNode
                              ); 
                              UaStatus s = sourceVariableThreads->addJob (job);
                              if (!s.isGood())
                              {
                                  LOG(Log::ERR) << "While addJob(): " << s.toString().toUtf8();
                              }
                              return s;
                              </xsl:when>
                              <xsl:when test="@addressSpaceRead='synchronous'">
                              IoJob_<xsl:value-of select="$className"/>_READ_<xsl:value-of select="@name"/> job (
                              callback,
                              hTransaction,
                              callbackHandle,
                              parentNode
                              ); 
                              job.execute();
                              </xsl:when>
                          <xsl:otherwise>
                          <xsl:message terminate="yes">Something got wrong.</xsl:message>
                          </xsl:otherwise>
                          </xsl:choose>
                      }
                          return OpcUa_Good;
          
                      </xsl:if>
                  
              </xsl:otherwise>
          </xsl:choose>

</xsl:for-each>
</xsl:for-each>
default:
return OpcUa_Bad;
}
}

UaStatus SourceVariables_spawnIoJobWrite (		
ASSourceVariableJobId jobId,
IOManagerCallback *callback,
OpcUa_UInt32 hTransaction,
OpcUa_UInt32        callbackHandle,
const UaNode *parentNode,
OpcUa_WriteValue*   pWriteValue
)
{
if (! sourceVariableThreads)
throw std::runtime_error("Attempted Source Variable operation, but Source Variable threads are not up.");
switch (jobId)
{
<xsl:for-each select="/d:design/d:class">
<xsl:variable name="className"><xsl:value-of select="@name"/></xsl:variable>
<xsl:for-each select="d:sourcevariable">
      

<xsl:if test="@addressSpaceWrite!='forbidden'">
        
case <xsl:value-of select="fnc:sourceVariableWriteJobId($className,@name)"/>:
          <xsl:choose>
              <xsl:when test="fnc:classHasDeviceLogic(/,$className)!='true'">
                  return OpcUa_BadNotImplemented; // because this class has no device logic
              </xsl:when>

              <xsl:otherwise>
                 {
                  <xsl:if test="@addressSpaceWrite='asynchronous' or @addressSpaceWrite='synchronous'">
                  <xsl:choose>
                      <xsl:when test="@addressSpaceWrite='asynchronous'">
              
                      IoJob_<xsl:value-of select="$className"/>_WRITE_<xsl:value-of select="@name"/> *job =
                      new IoJob_<xsl:value-of select="$className"/>_WRITE_<xsl:value-of select="@name"/> (
                      callback,
                      hTransaction,
                      callbackHandle,
                      parentNode,
                      pWriteValue
                      ); 
                      UaStatus s = sourceVariableThreads->addJob (job);
                      if (!s.isGood())
                      {
                          LOG(Log::ERR) << "While addJob(): " << s.toString().toUtf8();
                      }
                      return s;
                      </xsl:when>
                      <xsl:when test="@addressSpaceWrite='synchronous'">
                      
                      IoJob_<xsl:value-of select="$className"/>_WRITE_<xsl:value-of select="@name"/> job (
                      callback,
                      hTransaction,
                      callbackHandle,
                      parentNode,
                      pWriteValue
                      ); 
                      job.execute();
                      
                      </xsl:when>
                      <xsl:otherwise>
                          <xsl:message terminate="yes">Something got wrong.</xsl:message>
                      </xsl:otherwise>
                  </xsl:choose>
              
              
                 }
                 return OpcUa_Good;

          </xsl:if>
              
              </xsl:otherwise>
          </xsl:choose>
          
          </xsl:if>


</xsl:for-each>
</xsl:for-each>
default:
return OpcUa_Bad;
}
}

  }

#endif // BACKEND_OPEN62541

</xsl:template>
